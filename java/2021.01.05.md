# ArrayList

- 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일
- ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다
- List인터페이스를 구현하므로, 저장순서가 유지되거 중복을 허용한다
- 데이터의 저장공간으로 배열을 사용한다

# ArrayList에 저장된 객체의 삭제 과정

1. 삭제할 데이터 아래의 데이터를 한 칸씩 복사해서 삭제할 데이터를 덮어쓴다
2. 데이터가 모두 한 칸씩 이동했으로 마지막 데이터는 null로 변경한다
3. 데이터가 삭제되어 데이터의 개수가 줄었으므로 size의 값을 감소시킨다

# 배열의 장단점

▶ 장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간이 짧다
▶ 단점1 : 크기를 변경할 수 없다 (크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야함)
▶ 단점2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다

# LinkedList - 배열의 단점을 보완

- 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결

▶ 데이터의 삭제 : 단 한번의 참조변경만으로 가능
▶ 한번의 Node객체 생성과 두 번의 참조변경만으로 가능
▶ 단점 : 데이터 접근성이 나쁨
▶ 더블리 링크드 리스트 - 이중 연결리스트, 접근성 향상
▶ 더블리 서큘러 링크드 리스트 - 이중 원형 연결리스트

# 스택과 큐

▶ 스택 : LIFO구조. 마지막에 저장된 것을 제일 먼저 꺼내게 된다 (배열로 구현하면 효율적)
▶ 큐 : FIFO구조. 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다 (링크드 리스트로 구현하면 효율적)

# 스택의 메서드

|메서드|설명|
|---|---|
|boolean empty()|Stack이 비어있는지 알려줌|
|Object peek()|Stack의 맨위에 저장된 객체를 반환|
|Object pop()|Stack의 맨 위에 저장된 객체를 꺼낸다|
|Object push(Object item)|Stack에 객체를 저장한다|
|int search(Object o)|Stack에서 주어진 객체를 찾아서 그 위치를 반환. 못찾으면 -1|

# 큐의 메서드

|메서드|설명|
|---|---|
|boolean add(Object o)|지정된 객체를 Queue에 추가|
|Object remove()|Queue에서 객체를 꺼내 반환 비어있으면 예외 발생|
|Object element()|삭제없이 요소를 읽어옴. 비어있으면 예외 발생|
|boolean offer(Object o)|Queue에 객체를 저장|
|Object poll()|Queue에 객체를 꺼내서 반환. 비어있으면 null반환|
|Object peek()|삭제없이 요소를 읽어옴. 비어있으면 null 반환|
